# 算法简介
## 二分查找
1. 二分查找的前提是：输入是一个有序的元素列表  
2. 对于二分查找，最多需要log2(n)步骤，而简单查找最多需要n步  
3. 大O表示法的单位并不是秒，而是让你能够比较的操作数，它指出了算法运行时间的曾速；（操作数指的就是计算次数）  
4. 大O表示法说的是最糟糕的时间，有时候还需要考虑平均时间；  
5. 谈论算法速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加；  
# 选择排序
## 数组和链表
1. 数组  
1.1 额外请求的内存空间，如果没有用满，会造成资源的浪费；  
1.2 需要存储的内容超过初始请求的内存空间后，需要整体转移内存;  
1.3 数组插入元素时比较难，需要整体移动内存  
1.4 数组方便进行元素的访问；  
2. 链表  
2.1  链表的元素可以存储在内存的任何地方，内存的每个元素存储了下一个元素的地址，从而使一系列的随机内存串在一起；  
2.2  链表插入元素比较方便，直接在想插入的地方进行  
2.3  链表读取数据时比较慢，需要从第一个元素开始找下一个元素的地址，不能直接进行数据的访问；(这里说的读取元素是指随机进行读取，整体读取时其实不慢) 
2.4  链表只支持顺序访问，不支持随机访问；  
2.5  混合数据结构：链表数组（插入速度与链表相当，查找速度比数组慢，但比链表要快 
3. 选择排序  
3.1 　选择排序的本质是：每次去找剩下的元素中最大（或最小）的元素放到对应的位置，遍历所有元素进行排序;  
3.2 　选择排序的速度是O(n2), 而快速排序是O(nlog(n));  
##  递归
1. 递归  
1.1 递归：递归就是自己调用自己;  
1.2 递归函数一般由两部分构成，分别是基线条件和递归条件。其中基线条件是让函数不再调用自己，跳出循环调用的条件；递归条件是让函数继续调用自己的条件；  
2. 栈  
2.1 栈的存入和删除都在最前面；  
2.2 在一个函数中调用另外一个函数，当前函数暂停并处于未完成的状态，但其中的值都还存在内存中，新调用的函数会堆在前面这个函数栈的上面；  
2.3 使用调用栈对函数的变量进行存储；  
2.4 在调用栈中不同函数之间的变量不能相互访问；  
2.5 栈的缺点是要耗费大量的内存空间存储详细的函数信息；  
2.6 解决栈存储空间过大的问题两种方法：１．转而使用循环；　２．使用尾递归  
2.7 栈的操作有两种：压入和弹出，都是针对最新的元素进行操作;  
## 快速排序  
1. ＤＣ算法——份儿治之；  
1.1. 找基线条件：问题最简单的状态是什么样的，达到了这个条件结果是显而易见的，且满足这个条件后递归就可以跳出了；  
1.2. 找递归条件：逐步接近基线状态或基线条件；  
1.3. 编写涉及数组的基线条件时往往的状态是：数组为空或者数组只包含一个元素;  
1.4. 快速排序：1.选择基准值；2. 将数组分为两个子数组，一个小于基准值的数组和大于基准值的数组；　3. 对这两个子数组进行排序；4.重复操作，递归
1.5. 大Ｏ表示法中，常数常常忽略不计；  
1.6. 平均情况和最糟糕情况；(TBD)  

## 散列表
1. 散列表  
1.1 python中的字典，Ｃ＋＋中的map;  
1.2 散列表的本质是一种映射关系，由散列函数完成键到值的映射。散列函数需要满足两点，一是映射结果的一致性；二是映射的确定性，不同的输入，不同的结果; 
1.3 散列表总是将同样的输入映射到相同的索引，将不同的输入映射到不同的索引，散列函数知道数组有多大，只返回有效的索引；映射的输入是键，输出是索引;  
1.4 散列表获取元素的速度和数组一样快;  
1.5 散列表能够用作缓存，存储一些需要快速响应的数据;  
1.6 冲突：给两个键分配的位置相同；解决方法：如果两个键映射到同一个位置，就在这个位置存储一个链表；
1.7 散列表执行操作的时间为Ｏ(1),这是一个常量时间，就是指不管散列表多大，所需的时间都相同;  
1.8 散列表查找的速度与数组一样快，删除和插入的速度与链表一样快，兼具两者的优点;  
1.9 避免冲突至关重要：较低的装填因子，良好的散列函数;  
1.10 散列表的装填因子一旦达到0.7,就该调整散列表的长度;  
1.11 散列表非常适合用于防止重复;  

## 广度优先搜索算法
1. 图
1.1 图模拟一组连接；
1.2 图由节点和边组成，相互连接的节点可以称为邻居；
1.3 不相邻的节点不能称为邻居；

2. 广度优先搜索算法
2.1 广度优先搜索算法可用于解决两类问题：１）从节点Ａ出发，有前往节点Ｂ的路径吗？　２）从节点Ａ出发，前往节点Ｂ的哪条路径最短；
2.2 队列是一种“先进先出”的数据结构，栈是一种“后进先出”的数据结构；
2.3 有向图：用于表征单项的关系；　无向图：表征相互关联的关系；
2.4 广度优先搜索算法的运行时间为：O(V+E);
2.5 拓扑排序：有顺序的图；
2.6 使用广度优先搜索算法时：对于检查过的人，务必不要重复检查，否则会导入无限循环；
2.7 广度优先搜索算法的思路：１）用字典创建“图”；　２）创建一个队列，用于存储要检查的人；３）从队列中弹出一个人，检查这个人是否是想找的，如果是，结束，如果不是将这个人标记为已经检查，并将这个人的邻居加入到待检查的队列中；

## 迪克斯特拉算法
1. 加权图  　　
1.1 在图的基础上，若边上有权重，也即每条边（关系）的比重不一样；
2. 迪克斯特拉算法
2.1 适用于找出最快的路径;  
2.2 步骤：１）找出“最便宜"的节点；２）更新该节点的邻居的开销（从全局的角度更新，就是指从起点开始到这个邻居的开销）；３）重复这个过程，直到对图中的每个节点都这样做；４）得到最终路径;  
2.3 仅仅当权重为正时，迪克斯特拉算法才管用，如果图中包含负权边，使用贝尔曼－福德算法;  

## 贪婪算法
1. 贪婪算法
1.1 贪婪算法可以用在没有找到完美的解决方案，只能够大致解决问题;  
1.2 贪婪算法就是每一次都选择最优解，然后综合起来作为最终解;  
1.3 集合;  
1.4 NP 完全问题：你需要计算所有的解，并从中选出最小/最短的那个;  
1.5 涉及”所有组合”的问题通常是ＮＰ完全问题;  
1.6 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解;  
1.7 面临NP完全问题时，最佳的做法是使用近似算法;  

## 动态规划
1. 动态规划
1.1 动态规划，先解决子问题，再逐步解决大问题;  
1.2 动态规划功能强大，他能解决子问题，并使用这些答案来解决大问题。但仅仅当每个子问题都是离散的，即不依赖于其它子问题时，动态规划才管用;  
1.3 动态规划可以帮助你在给定约束条件下找到最优解;  
1.4 最长子串问题;  

## K最近邻算法
1. 分类就是编组，回归就是预测结果；
2. 挑选合适的特征；
3. 计算相识度：欧氏距离，余弦相识度；

## 其它
1. 树，二叉树：对于其中的节点，左子节点的值都比它小，而右子节点的值都比它大；
2. 二叉树的插入和查找速度很快，但是也存在缺点，不能随机访问；
3. 反向索引----常用于搜索引擎；
4. 傅里叶变换：给它一杯冰沙，他能告诉你其中包含哪些成分;  
5. 并行算法：并行性管理开销，　负载均衡；
6. 映射函数，归并函数；
7. 布隆过滤器；
8. SHA算法；
9. 线性规划;  






