# 算法简介
## 二分查找
1. 二分查找的前提是：输入是一个有序的元素列表  
2. 对于二分查找，最多需要log2(n)步骤，而简单查找最多需要n步  
3. 大O表示法的单位并不是秒，而是让你能够比较的操作数，它指出了算法运行时间的曾速；（操作数指的就是计算次数）  
4. 大O表示法说的是最糟糕的时间，有时候还需要考虑平均时间；  
5. 谈论算法速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加；  
# 选择排序
## 数组和链表
1. 数组  
1.1 额外请求的内存空间，如果没有用满，会造成资源的浪费；  
1.2 需要存储的内容超过初始请求的内存空间后，需要整体转移内存;  
1.3 数组插入元素时比较难，需要整体移动内存  
1.4 数组方便进行元素的访问；  
2. 链表  
2.1  链表的元素可以存储在内存的任何地方，内存的每个元素存储了下一个元素的地址，从而使一系列的随机内存串在一起；  
2.2  链表插入元素比较方便，直接在想插入的地方进行  
2.3  链表读取数据时比较慢，需要从第一个元素开始找下一个元素的地址，不能直接进行数据的访问；(这里说的读取元素是指随机进行读取，整体读取时其实不慢)  
2.4  链表只支持顺序访问，不支持随机访问；  
2.5  混合数据结构：链表数组（插入速度与链表相当，查找速度比数组慢，但比链表要快  
3. 选择排序  
3.1 　选择排序的本质是：每次去找剩下的元素中最大（或最小）的元素放到对应的位置，遍历所有元素进行排序;  
3.2 　选择排序的速度是O(n2), 而快速排序是O(nlog(n));  
##  递归
1. 递归
1.1 递归：递归就是自己调用自己
1.2 递归函数一般由两部分构成，分别是基线条件和递归条件。其中基线条件是让函数不再调用自己，跳出循环调用的条件；递归条件是让函数继续调用自己的条件；  
2. 栈  
2.1 栈的存入和删除都在最前面；  
2.2 在一个函数中调用另外一个函数，当前函数暂停并处于未完成的状态，但其中的值都还存在内存中，新调用的函数会堆在前面这个函数栈的上面；  
2.3 使用调用栈对函数的变量进行存储；  
2.4 在调用栈中不同函数之间的变量不能相互访问；  
2.5 栈的缺点是要耗费大量的内存空间存储详细的函数信息；  
2.6 解决栈存储空间过大的问题两种方法：１．转而使用循环；　２．使用尾递归
2.7 栈的操作有两种：压入和弹出，都是针对最新的元素进行操作;  
## 快速排序  
1. ＤＣ算法——份儿治之；  
1.1. 找基线条件：问题最简单的状态是什么样的，达到了这个条件结果是显而易见的，且满足这个条件后递归就可以跳出了；  
1.2. 找递归条件：逐步接近基线状态或基线条件；  
1.3. 编写涉及数组的基线条件时往往的状态是：数组为空或者数组只包含一个元素;  
1.4. 快速排序：1.选择基准值；2. 将数组分为两个子数组，一个小于基准值的数组和大于基准值的数组；　3. 对这两个子数组进行排序；4.重复操作，递归



